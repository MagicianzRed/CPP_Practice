# 第八章    异常控制流

## 学习目标：

- **进程的基本概念**
- **进程是如何工作的？**
- **在应用程序中创建和操纵进程**
- **如何通过 Linux 系统调用来使用多个进程**
- **初步了解并发执行的不确定的行为**

## 8.1    异常

**本节概要：**

- **首先，介绍应用程序发送异常指令后，处理器会进行 异常处理 ，处理完成后会根据引起   异常事件的类型，返回的三种操作。**
- **紧接着阐述，从软件和硬件的双角度出发，处理器是介绍异常处理的过程**
- **随后，小结了异常事件的类型大体上被分为4种，每一种都用图文说明了 处理的过程 以及对应的 返回操作**

- **最后，以 Linux 操作系统举例，示例了 Linux 中的异常类型，简单展示了 Linux 系统调用（系统级函数）**

### 8.1.1    异常处理

- **异常号：（软硬件分工）**
  - **硬件：**其中一些号码是由 处理器的设计者分配
    - 这里包括被 除零、缺页、内存方位违例、断点以及算数运算溢出
  - **软件：**其他号码是由操作系统内核（操作系统常驻内存的部分）的设计者分配的。
    - 这里包括 系统调用 和 来自外部 I/O 设备的信号

- **处理逻辑**
  1. 系统启动时（上电），操作系统分配和初始化一张跳转表（异常表）
  2. 运行时（执行某个程序时），处理器检测（电压异常啥的）到发生了一个事件，并且确定了相应的异常号
  3. 随后，处理器出发异常——通过异常表的标目，转到相应的处理程序

- **异常有点向过程调用，重要不同之处如下：**
  - 过程调用，在跳转到处理程序之前，处理器将返回地址压入栈中。
    - 但是，根据异常类型，返回地址要么时当前指令，要么是下一条指令
  - 处理器也会把一些额外的状态压到栈中，在处理程序返回时，重新开始执行被中断的程序会需要这些状态
  - 如果控制从用户程序转移到内核，所有这些项目都不会被压到内核的栈中，而不是用户栈中
  - 异常处理程序运行在内核模式下，这意味着所有的系统资源都有完全的访问权

### 8.1.2    异常的类别

*同步异常 是 执行一套指令的直接产物*

- #### 中断 —— 异步，总是返回到下一条指令

  - 中断是异步发生的，是来自处理器外部 I/O设备的信号结果

- #### 陷阱和系统调用 —— 同步，总是返回到下一条指令

  - 陷阱是 **有意的异常**
  - 陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，叫做**系统调用**

- #### 故障 —— 同步，可能返回到当前指令

  - 故障由 错误情况引起，它可能能够被故障处理程序修正
  - 可以通过阅读书中例子，更加清楚故障的执行过程

- #### 终止 —— 同步，不会返回

  - 不可恢复的致命错误造成的结果

### 8.1.3   Linux/x86-64 系统中的异常

- #### Linux/x86-64 故障和终止

- #### Linux/86-64 系统调用

## 8.2    进程

**本节概要：**

- **首先介绍进程的基本概念 —— 一个执行中程序的实例，并给出学习目标：**
  - **一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占地使用处理器**
  - **一个私有地地址空间，它提供一个假象，好像我们地程序独占地使用我们地内存系统**
- **紧接着就介绍，逻辑控制流，程序计数值（PC），解释说明如何实现在多个进程之间切换，使得程序“看上去” 在独占的使用处理器**
- **同时也一并介绍了，并发流，简言之是逻辑流的一种形式**

- **然后是，私有地址空间，用一幅图来说明整个进程地址空间组织结构（Linux）**
- **顺便解释说明了，用户模式和内核模式（Linux）**
- **最后，解释了什么是 上下文切换（较高层形式的异常控制流）**

### 8.2.1    逻辑控制流

- 一系列的程序计数器（PC）的值
- 这些值，唯一地对应于在程序地可执行目标文件中地指令
- 或者包含在运行时动态链接到程序地共享对象中地指令

- **如何实现这种假象：**
  - 进程是轮流使用处理器
  - 每个进程执行它地流地一部分，然后被抢占（暂时挂起），然后轮到其他进程

### 并发流

- 一个逻辑流的执行在时间上与另一个流重叠

- **什么是时间上的重叠？**
  - 当且仅当 X 在 Y 开始之后和 Y 结束之前开始
  - 或者        Y 在 X 开始之后和 X 结束之前开始

- **并发：**
  - 多个流并发的执行的现象

- **多任务：**
  - 一个进程和其他进程轮流运行

- **时间片：**
  - 一个进程执行它控制流的一部分的每一时间段

- **多任务也叫时间分片**

- **注意：并发流的思想与流运行的处理器核心数或者计算器数无关**
- **并行流：**
  - 两个流并发地运行在不同处理器或者计算机上

### 8.2.3    私有地址空间

- 在一台 n 位地址地机器上，地址空间是 (2^n) - 1。
- 一般而言，和这个空间中某个地址相关联地那个内存字节是不能被其他进程读写的

- **组织结构（Linux）：**
  - 地址空间 *底部*（保留给用户程序的），通常包括代码、数据、堆和栈段。
  - 代码段总是从 0x0040 0000 开始。
  - 地址空间 *顶部*（保留给内核）操作系统常驻内存部分，包含内核在代表进程执行指令时（比如应用程序调用时）使用的代码、数据和栈（2^48 - 1）

### 8.2.4    用户模式和内核模式

- **如何限制一个应用执行的指令以及它可以访问的地址空间范围：**
  - 处理器通常用某个控制寄存器中的一个位模式来提供这种功能
  -  内核模式中的进程，可以执行指令集中的任何指令
  - 没有设置位模式，进程就在用户模式中

### 8.2.5     上下文切换

- 内核位每个进程维持一个**上下文**。
- 上下文，就是内核重新启动一个被抢占的进程所需的状态
  - **上下文：**
    - 它由一些对象的值组成，这些对象包括：
      - 通用目的寄存器、浮点寄存器、程序计数器、状态寄存器
      - 用户栈、内核栈
      - 各种内核数据结构
      - 比如：描述地址空间页表，包含当前进程信息的进程表，以及已经打开文件的信息的文件表

- 

