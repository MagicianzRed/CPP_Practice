# 第九章   顺序容器

**1. 一个容器就是一些特定类型对象的集合。**

**2. 顺序容器 为我们提供了控制元素 存储和访问顺序的能力。**

- **这种顺序不依赖于元素的值，而是元素加入容器时的位置相对应**
- **在 第11章会介绍 有序和无序关联的容器，根据关键字的值来存储元素**

## 9.1    顺序容器概述

**1. 标准库中的顺序容器 P292 表 9.1**

*新标准库的容器比旧版本的快得多，原因在后续章节介绍*

- #### 确定使用哪种顺序容器
  -  **除非你有很好的理由选择其他容器，否则应使用 vector**
  - **如果你的程序有很多小元素，且空间的额外开销很重要，则不要使用 list 或者 forward_list**
  - **如果程序要求随机访问元素，应该使用 vector 或 deque**
  - **如果程序要求在容器的 中间 插入或者删除元素，应使用 list 或 forward_list**
  - **如果程序需要在 头尾位置 插入或者删除元素，但不会在中间位置进行插入或删除操作，则使用 deque**
  - **如果程序只有在 读取输入 时才需要在容器中间位置插入元素，随后需要随机访问则：**
    - **首先，确定是否真的需要在容器中间位置添加元素。标准库中的 sort函数，可以重新排列容器中的元素**
    - **如果必须在中间位置插入元素，考虑在输入阶段使用 list ，一旦输入完成，将 list 中的内容拷贝到一个vector 中**
  - ***如果既要随机访问，又要在容器中插入？ 则需要对 list 或者 forward_list 与 vector 或者 deque 在实际应用中进行性能测试***



## 9.2    容器库概览

*本节将介绍 所有容器 都适用的操作，本章剩余部分将会聚焦于仅适用于顺序容器的操作*

- #### 对容器可以保存的元素类型的限制

  - 虽然我们在可以容器中几乎保存任何类型，但是某些容器对元素类型有其自己的特殊要求

### 9.2.1    迭代器

- #### 迭代器范围

  - **左闭合区间**

- #### 使用左闭合范围苑蕴含的变成假定

  - 如果 begin 与 end 相对，则范围为空
  - 如果 begin 与 end 不等，则范围至少包含一个元素，且 begin 指向该范围中的第一个元素
  - 我们可以对 begin 递增若干次，使得 begin == end

### 9.2.2     容器类型成员

- **表9.2开头部分**

### 9.2.3    begin 和 end 成员

- **r 开头的版本返回 反向迭代器**
- **c 开头的版本返回 const 迭代器**
- *当不需要写访问时，应使用 cbegin 和 cend*

### 9.2.4    容器定义和初始化

- #### 将一个容器初始化为另一个容器的拷贝

  1. 直接拷贝整个容器
     - **两个容器的类型 和 元素类型 必须匹配**

  2. 拷贝由一个迭代器对指定的元素范围
     - **只要求能将要拷贝的元素转换为要初始化的元素即可**

- #### 列表初始化

- #### 顺序容器大小相关的构造函数

  - 只有顺序容器的构造函数才接受大小参数，关联容器不支持

- #### 标准库 array 具有固定大小

### 9.2.5    赋值和 swap

*如果两个容器原本的大小不同，赋值运算后，两者的大小都与右边容器的原大小相同*

- #### 使用 assign （仅顺序容器）（不适用于 array）

- #### 使用 swap

***1. 赋值相关运算，会导致指向 左边容器 内部的迭代器、引用和指针失效。***

***2. swap 操作将容器内容交换，不会导致指向容器的迭代器、引用和指针失效（array 和 string 除外）***

### 9.2.6    容器大小操作

### 9.2.7    关系运算符

- #### 容器的关系运算符使用 元素的关系运算符完成比较

***关系运算符左右两边的运算对象必须是相同类型的容器，且必须保存相同类型的元素***

## 9.3    顺序容器的操作

### 9.3.1    向顺序容器添加元素

*当我们使用一个对象来初始化容器时，或者将一个对象插入到容器中时。*

*放入到容器中的实际上时对象值的一个拷贝*

- #### 使用 push_back

- #### push_front （vector 不支持）

- #### 在容器中的特定位置添加元素

  -  insert 函数将元素插入到 迭代器指定的位置之前

- #### 插入到范围内元素

- #### 使用 insert 的返回值

  - 返回指向 新添加的第一个元素的迭代器。（仔细看 表9.5 P305）

- #### 使用 emplace 操作

### 9.3.2    访问元素

- #### 访问成员函数返回的是引用

- #### 下标操作和安全的随机访问

### 9.3.3    删除元素

- #### pop_front 和 pop_back 成员函数

- #### 从容器内部成员删除一个元素

- #### 删除多个元素

### 9.3.4    特殊的 forward_list 操作

*forward_list 是一个单项链表*

### 9.3.5    改变容器大小

### 9.3.6    容器操作可能使迭代器失效

- **在向容器添加元素后**
  - 如果容器是 vector 或 string，且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。
    - 如果存储空间未重新分配，指向 **插入位置之前** 的元素的迭代器、指针和引用仍然有效——我建议直接重新创建一个新的
  - 对于 deque，**插入到除首尾位置**之外的任何位置都会导致迭代器、指针和引用失效。
    - 如果在首尾位置**添加**元素，迭代器会失效，但指向存在的元素的引用和指针不会失效
  - 对于 list 和 forward_list，指向容器的迭代器（包括首尾迭代器）指针和引用全部有效

- **当我们删除一个元素**

  - 对于 list 和 forward_list，指向容器的迭代器（包括首尾迭代器）指针和引用全部有效

  - 对与 deque，如果**首尾之外**任何位置元素被删除，那么指向被删除元素外其他元素的迭代器、引用和指针失效。

    ***当我们删除元素的时候，尾后迭代器总是会失效***

**当你使用迭代器（或者指向容器元素的引用或指针）时，最小化要求 迭代器必须保持 有效的程序片段 是一个好的方法————没看懂，我只知道，只要添加或者删除容器中的元素的时候必须更新迭代器或者重新定位**

- #### 编写改变容器环境的程序

- #### 不要保存 end 返回的迭代器

## 9.4    vector 对象是如何增长的

*vector 和 string 的实现通常会分配比新的空间需求更大的的内存空间——说人话就是你设定多少，它给你扩大空间，依据你的机器（怎么实现的并不知道）*

- #### 管理容量的成员函数

- #### capacity 和 size

  - capacity 返回 —— 不重新分配空间的前提，最多可以保存的元素

  - size 返回 —— 已经保存的元素的数目

## 9.5    额外的 string 操作

### 9.5.1  构造 string 的其他方法（仔细阅读 表9.11 （P321））

- #### substr操作 —— 返回一个 string，它是原始 string 的一部分或者全部



### 9.5.2    改变 string 的其他方法

- #### append 和 replace 函数

  - append —— 在 string 末尾进行插入操作的一种简写形式
  - replace 操作是调用 erase 和 insert 的一种简写形式

- #### 改变 string 的多种重载函数

### 9.5.3    string 搜索操作（表9.14 P325）

*搜素失败返回 npos（无符号类型）*

- #### 指定在哪里开始搜索

- #### 逆向搜索



### 9.5.4    compare 函数

**他们与 strcmp 函数很相似**



### 9.5.5 数值转换  ——  表9.16（P328）



## 9.6    容器适配器

**容器、迭代器和函数都有适配器**

**本质上，一个适配器 是 一种机制，能使某种事物的行为看起来向另外一种事物一样**




