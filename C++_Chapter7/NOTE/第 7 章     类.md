# 第 7 章     类

## 7.1     定义抽象数据类型

### 7.1.1     设计 Sales_data 类

- #### 使用改进的 Sales_data 类

### 7.1.2    定义改进的 Sales_data 类

- #### 定义成员函数

- #### 引入 this

- #### 引入 const 成员函数

- #### 类作用域和成员函数

- #### 定义一个返回 this 对象的函数

### 7.1.3    定义相关的非成员函数

- #### 定义 read 和 print 函数

- #### 定义 add 函数

### 7.1.4     构造函数

- #### 合成的默认构造函数

- #### 某些类不能依赖于合成的默认构造函数

  - 编译器只有在发现类不包含任何构造函数的情况下会替我们生成
  - 合成的构造函数可能执行错误的操作（初始值未定义）
  - 有些时候编译器不能为某些合成默认的构造函数（如果类中包含**其他类成员**且这个成员的类型**没有默认构造函数**，）

- #### 定义 Sales_data 的构造函数

- #### 构造函数初始值列表

- #### 在类的外部定义构造函数

#### 7.1.5    拷贝、赋值和析构

- #### 某些类不能依赖于合成的版本

  - 当类需要分配类对象之外的资源时，合成的版本常常会失效

## 7.2    访问控制与封装

- #### 使用 class 或者 struct

  - 当我们希望定义的类的所有成员都是 public 时，使用struct
  - 反之，如果有成员希望是 private，则定义 class

### 7.2.1 友元

**想要使得 其他类或者函数 访问自己建立的类的非公有成员 方法是令他们成为 友元**

- #### 友元的声明

  - 友元的声明仅仅指定了访问权限
  - 如果希望用户能够调用 友元声明 我们必须专门在友元声明之外再次声明一次
  - 注意：有些编译器可以允许不用声明就可以被调用

## 7.3    类的其他特性

### 7.3.1    类成员再探

- #### 定义一个类型成员

- #### Screen 类的成员函数

- #### 令成员作为内联函数

- #### 重载成员函数

- #### 可变数据成员

  - 可以在 const 成员函数中改变 mutable 成员的值

- #### 类数据成员的初始值

### 7.3.2     返回 *this 的成员函数

```c++
myScreen.move(4, 0).set('#');
/*上面语句等价于*/
myScreen.move(4, 0);
myScreen.set('#');
/*
	set函数返回 Sreen类的 *this ，因此可以直接利用返回值再次调用成员函数
*/
```

- #### 从 const 成员函数返回 *this

  - 一个 const 成员函数如果以引用的形式返回 *this，那么他的返回类型是 常量引用

- #### 基于 const  的重载

### 7.3.3    类类型

- #### 类声明

### 7.3.4    友元再探

- **类之间的友元关系**
  - **如果一个类指定了友元类，则友元类的 成员函数 可以访问此类包括非公有成员**
  - **需要注意的是：友元关系不存在传递性——每个类负责控制自己的友元类或者函数**

- **令函数成员作为友元**
  - **我们可以为某个类的函数单独成为其 友元函数 **
  - **必须按照一下规则：**
    - 首先定义 A 类，其中声明 clear 函数，但是不能定义它。在 clear 使用  B 类的成员之前必须声明 B
    - 接下来定义 B 类，包括对于友元函数 clear 的声明。
    - 最后定义 clear，此时 这个 clear 函数才能使用 B 类的成员

- **函数重载和友元**

- **友元声明和作用域**

  - **即使是在 类 的内部定义友元函数，我们仍然无法使用它，需要在外部再声明一次才能使用**

    

    ***注意：有的编译器不强制上述有关友元限定的规则***



## 7.4    类的作用域

- #### 作用域和定义在类外部的成员

  - 这里很好的解释了为什么定义类的成员函数的作用域为啥在函数前，而不是在返回值前

### 7.4.1    名字查找与类的作用域

- 总而言之，想要定义类型名，尽可能在类的最开始处定义，就如同C一样在最顶端定义好所有的名称

- #### 用于类成员声明的名字查找

- #### 类型名称要特殊处理

- #### 成员定义中的普通块作用域的名字查找

- #### 类作用域之后，在外围的作用域中查找

- #### 在文件中名字的出现处对其进行解析

***当出现这种类似的BUG的时候再去考虑这些把，即——当出现命名不规范的情况下会出现的问题（就是偷懒想起一样的名字）***

## 7.5    构造函数再探













