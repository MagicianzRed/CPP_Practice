# 第 7 章     类

## 7.1     定义抽象数据类型

### 7.1.1     设计 Sales_data 类

- #### 使用改进的 Sales_data 类

### 7.1.2    定义改进的 Sales_data 类

- #### 定义成员函数

- #### 引入 this

- #### 引入 const 成员函数

- #### 类作用域和成员函数

- #### 定义一个返回 this 对象的函数

### 7.1.3    定义相关的非成员函数

- #### 定义 read 和 print 函数

- #### 定义 add 函数

### 7.1.4     构造函数

- #### 合成的默认构造函数

- #### 某些类不能依赖于合成的默认构造函数

  - 编译器只有在发现类不包含任何构造函数的情况下会替我们生成
  - 合成的构造函数可能执行错误的操作（初始值未定义）
  - 有些时候编译器不能为某些合成默认的构造函数（如果类中包含**其他类成员**且这个成员的类型**没有默认构造函数**，）

- #### 定义 Sales_data 的构造函数

- #### 构造函数初始值列表

- #### 在类的外部定义构造函数

#### 7.1.5    拷贝、赋值和析构

- #### 某些类不能依赖于合成的版本

  - 当类需要分配类对象之外的资源时，合成的版本常常会失效

## 7.2    访问控制与封装

- #### 使用 class 或者 struct

  - 当我们希望定义的类的所有成员都是 public 时，使用struct
  - 反之，如果有成员希望是 private，则定义 class

### 7.2.1 友元

**想要使得 其他类或者函数 访问自己建立的类的非公有成员 方法是令他们成为 友元**

- #### 友元的声明

  - 友元的声明仅仅指定了访问权限
  - 如果希望用户能够调用 友元声明 我们必须专门在友元声明之外再次声明一次
  - 注意：有些编译器可以允许不用声明就可以被调用

## 7.3    类的其他特性

### 7.3.1    类成员再探

- #### 定义一个类型成员

- #### Screen 类的成员函数

- #### 令成员作为内联函数

- #### 重载成员函数

- #### 可变数据成员

  - 可以在 const 成员函数中改变 mutable 成员的值

- #### 类数据成员的初始值

### 7.3.2     返回 *this 的成员函数

```c++
myScreen.move(4, 0).set('#');
/*上面语句等价于*/
myScreen.move(4, 0);
myScreen.set('#');
/*
	set函数返回 Sreen类的 *this ，因此可以直接利用返回值再次调用成员函数
*/
```

- #### 从 const 成员函数返回 *this

  - 一个 const 成员函数如果以引用的形式返回 *this，那么他的返回类型是 常量引用

- #### 基于 const  的重载

### 7.3.3    类类型

- #### 类声明

### 7.3.4    友元再探

- **类之间的友元关系**
  - **如果一个类指定了友元类，则友元类的 成员函数 可以访问此类包括非公有成员**
  - **需要注意的是：友元关系不存在传递性——每个类负责控制自己的友元类或者函数**

- **令函数成员作为友元**
  - **我们可以为某个类的函数单独成为其 友元函数 **
  - **必须按照一下规则：**
    - 首先定义 A 类，其中声明 clear 函数，但是不能定义它。在 clear 使用  B 类的成员之前必须声明 B
    - 接下来定义 B 类，包括对于友元函数 clear 的声明。
    - 最后定义 clear，此时 这个 clear 函数才能使用 B 类的成员

- **函数重载和友元**

- **友元声明和作用域**

  - **即使是在 类 的内部定义友元函数，我们仍然无法使用它，需要在外部再声明一次才能使用**

    

    ***注意：有的编译器不强制上述有关友元限定的规则***



## 7.4    类的作用域

- #### 作用域和定义在类外部的成员

  - 这里很好的解释了为什么定义类的成员函数的作用域为啥在函数前，而不是在返回值前

### 7.4.1    名字查找与类的作用域

- 总而言之，想要定义类型名，尽可能在类的最开始处定义，就如同C一样在最顶端定义好所有的名称

- #### 用于类成员声明的名字查找

- #### 类型名称要特殊处理

- #### 成员定义中的普通块作用域的名字查找

- #### 类作用域之后，在外围的作用域中查找

- #### 在文件中名字的出现处对其进行解析

***当出现这种类似的BUG的时候再去考虑这些把，即——当出现命名不规范的情况下会出现的问题（就是偷懒想起一样的名字）***

## 7.5    构造函数再探

### 7.5.1    构造函数初始值列表

- #### 构造函数的初始值有时必不可少

  - 当成员是 const 或者 引用 的话，必须将其初始化

- #### 成员初始化的顺序

  - 构造函数 初始值列表 的前后位置关系不会影响实际的初始化
  - **如果，用一个成员初始话另一个成员，那么顺序就很关键**
  - ***最好令构造函数 初始值的顺序 与 成员声明 的顺序保持一致。尽可能避免某些成员初始化另外的成员***

- #### 默认实参和构造函数

### 7.5.2    委托构造函数

```c++
class A
{
 public:
    // 非委托构造函数
    A(int num1, int num2) : sb1(num1), sb2(num2) { }
    // 其余构造函数
    A() : A(1,1);
    // 委托的委托
    A(int myNum) : A() { }
 private:
    int sb1;
    int sb2;
}
```

### 7.5.3    默认构造函数的作用

- **默认初始化在一下情况下发生：**
  - 当我们在 块作用域内 不使用任何初始值定义一个非静态变量
  - 当一个类本身含有类类型成员且使用合成的默认构造函数时
  - 当类类型的成员没有在构造函数**初始值列表**中显示初始化时

- **值 初始化在一下情况发生：**
  - 在数组初始化的过程中，如果我们提供的初始值数量少于数组的大小时
  - 当我们不使用初始值定义一个局部静态变量时
  - 当我们通过书写形如 T(  )  的表达式显示地请求初始化时，其中 T 是类型名

- #### 使用默认构造函数

### 7.5.4    隐式的类类型转换

*如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制*

- #### 值允许一步类型转换（见 P264 的示例）

- #### 类类型转换不是总有效

- #### 抑制构造函数定义的隐式转换
  - 通过将构造函数声明为 **explicit** 
  - **注意事项**：
    - 关键字：**explicit** 只对一个实参的构造函数有效
    - 在类外部定义的时候，关键字不允许重复

- **为转换显示地使用构造函数**

  *尽管被 explicit 抑制了，但是我们可以通过强制类型转换，来突破这层限制*

- #### 标准库中含有显示构造函数地类

### 7.5.5    聚合类

- **聚合类需要满足以下条件：**
  - 所有成员都是 public 的
  - 没有定义任何构造函数
  - 没有初始值
  - 没有基类，也没有 virtual 函数
  - *这个难道不是结构体吗。。。。。*

### 7.5.6    字面值常量类

- **数据成员都是 字面值类型 的 聚合类 **

- **但是如果复合以下要求，也是字面值常量类：**
  
  - 数据成员必须都是字面值
  - 类必须至少含有一个 constexpr 构造函数
  - 如果一个数据成员含有类初始值，则内置成员的初始值必须是一条常量表达式
  - 如果成员属于某种类类型，则初始值必须使用成员自己的 constexpr 构造函数
- 类必须使用析构函数的默认定义，该成员负责销毁类的对象
  
- ####  cosntexpr 构造函数

  - constexpr 构造函数可以声明成 = default 或者是 删除函数形式
  - 如果不想让编译器合成，就必须遵守 constexpr函数 和 构造函数 的要求













