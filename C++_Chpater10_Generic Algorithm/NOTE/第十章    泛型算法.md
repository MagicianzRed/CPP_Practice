# 第十章    泛型算法

*泛型算法和关于迭代器的更多细节，构成本章主要内容*

## 10.1    概述

*标准库并未给每个容器都定义成员函数来实现这些操作（查找特定元素，替换或者删除特定值）*

*于是为他们定义了泛型算法*

- **泛型**：
  
  - 它们可以用于不同类型的元素和多种容器类型
- **算法**：
  
- 他们实现了一些经典算法的公共接口
  
- #### 算法如何工作（find 举例）

  - 只要由一个迭代器可以用来访问元素，find 就完全不依赖于容器类型（甚至无需理会保存的元素是不是容器）

- #### 迭代器令算法不依赖容器，但是算法依赖于元素类型的操作

***泛型算法本身不会执行容器的操作，他们只会运行于迭代器之上***



## 10.2    初始泛型算法

*目的：理解 算法的解构 和 算法的统一原则*

### 10.2.1    只读算法

- #### 算法和元素类型（以 accumulate 为例）

  - **accumulate(p1, p2, p3) —— 前两个参数需要求和的元素范围，第三个参数是和的初值**
    - **第三个参数的类型决定了函数中使用哪个加法运算符以及返回值的类型**
  - 对于只读取而不改变元素的算法，通常最好使用 cbegin() 和 cend()
  - 如果你计划使用算法返回的迭代器来改变元素的值，就需要用 begin() 和 end()

- #### 操作两个序列的算法（以 equal 为例）

  - **equal(p1, p2, p3) —— 用于确定两个序列是否保存相同的值**
    - **前两个参数 是第一个序列的范围，第三个表示第二个序列的首元素**
    - **它基于一个重要的假设（使用前检查）第二个序列至少与第一个序列一样长**
    - 此算法要处理第一个序列中的每一个元素，因此它假定每个元素在第二个序列中都有一个与之对应的元素

  - ***那些只接受，一个单一迭代器 来表示 第二个序列的算法，都假定第二个序列至少与第一个一样长***

### 10.2.2    写容器元素的算法

**使用这类算法，必须注意确保 序列原大小 至少不小于 我们要求算法写入的元素数目**

- #### 算法不检查写操作（以 fill_n、fill 举例）

  - **fill(p1, p2, p3) —— 接受一对迭代器表示一个范围，还接受一个值作赋予输入序列中的每一个元素**
  - 向目的位置迭代器写入数据的算法，假定目的的位置足够大，能够容纳写入的元素

- #### 介绍 back_inserter

  - 是一种向容器中**添加元素**的迭代器

- #### 拷贝算法（以 copy、replace、replace_copy 举例）

  - **copy(p1, p2, p3) —— 参数与 fill 同理**
  - **replace(p1, p2, p3) —— 前两个是迭代器，表示输入序列，后两个一个是要搜索的值**
  - **replace_copy(p1, p2, p3,p4) —— 如果希望保留原序列不变，可以调用 replace_copy**
    - **p3 —— 指出调整后序列保存的位置**

### 10.2.3    重排容器元素的算法

*本小节以一段代码为例，介绍如何使用 这些算法*

```c++
void elimDups(vector<string> &words)
{
    // 按字典顺序排序 words, 以便查找重复单词
    sort(words.begin(), words.end());
    // unique 重排输出范围，使得每一个单词只出现一次
    // 排列在范围的前部，返回指向不重复区域 之后一个位置 的迭代器
    auto end_unique = unique(words.begin(), words.end());
    // 使用向量操作 erase 删除重复单词
    words.erase(end_unique, words.end());
}
```

- #### 消除重复单词

- #### 使用 unique

- #### 使用容器操作删除元素