# 第十章    泛型算法

*泛型算法和关于迭代器的更多细节，构成本章主要内容*

## 10.1    概述

*标准库并未给每个容器都定义成员函数来实现这些操作（查找特定元素，替换或者删除特定值）*

*于是为他们定义了泛型算法*

- **泛型**：
  
  - 它们可以用于不同类型的元素和多种容器类型
- **算法**：
  
- 他们实现了一些经典算法的公共接口
  
- #### 算法如何工作（find 举例）

  - 只要由一个迭代器可以用来访问元素，find 就完全不依赖于容器类型（甚至无需理会保存的元素是不是容器）

- #### 迭代器令算法不依赖容器，但是算法依赖于元素类型的操作

***泛型算法本身不会执行容器的操作，他们只会运行于迭代器之上***



## 10.2    初始泛型算法

*目的：理解 算法的解构 和 算法的统一原则*

### 10.2.1    只读算法

- #### 算法和元素类型（以 accumulate 为例）

  - **accumulate(p1, p2, p3) —— 前两个参数需要求和的元素范围，第三个参数是和的初值**
    - **第三个参数的类型决定了函数中使用哪个加法运算符以及返回值的类型**
  - 对于只读取而不改变元素的算法，通常最好使用 cbegin() 和 cend()
  - 如果你计划使用算法返回的迭代器来改变元素的值，就需要用 begin() 和 end()

- #### 操作两个序列的算法（以 equal 为例）

  - **equal(p1, p2, p3) —— 用于确定两个序列是否保存相同的值**
    - **前两个参数 是第一个序列的范围，第三个表示第二个序列的首元素**
    - **它基于一个重要的假设（使用前检查）第二个序列至少与第一个序列一样长**
    - 此算法要处理第一个序列中的每一个元素，因此它假定每个元素在第二个序列中都有一个与之对应的元素

  - ***那些只接受，一个单一迭代器 来表示 第二个序列的算法，都假定第二个序列至少与第一个一样长***

### 10.2.2    写容器元素的算法

**使用这类算法，必须注意确保 序列原大小 至少不小于 我们要求算法写入的元素数目**

- #### 算法不检查写操作（以 fill_n、fill 举例）

  - **fill(p1, p2, p3) —— 接受一对迭代器表示一个范围，还接受一个值作赋予输入序列中的每一个元素**
  - 向目的位置迭代器写入数据的算法，假定目的的位置足够大，能够容纳写入的元素

- #### 介绍 back_inserter

  - 是一种向容器中**添加元素**的迭代器

- #### 拷贝算法（以 copy、replace、replace_copy 举例）

  - **copy(p1, p2, p3) —— 参数与 fill 同理**
  - **replace(p1, p2, p3) —— 前两个是迭代器，表示输入序列，后两个一个是要搜索的值**
  - **replace_copy(p1, p2, p3,p4) —— 如果希望保留原序列不变，可以调用 replace_copy**
    - **p3 —— 指出调整后序列保存的位置**

### 10.2.3    重排容器元素的算法

*本小节以一段代码为例，介绍如何使用 这些算法*

```c++
void elimDups(vector<string> &words)
{
    // 按字典顺序排序 words, 以便查找重复单词
    sort(words.begin(), words.end());
    // unique 重排输出范围，使得每一个单词只出现一次
    // 排列在范围的前部，返回指向不重复区域 之后一个位置 的迭代器
    auto end_unique = unique(words.begin(), words.end());
    // 使用向量操作 erase 删除重复单词
    words.erase(end_unique, words.end());
}
```

- #### 消除重复单词

- #### 使用 unique（将相邻的重复项 “ 消除 ”）

- #### 使用容器操作删除元素

## 10.3   定制操作

### 10.3.1    向算法传递函数

- #### 谓词

  - 谓词是一个可调用的表达式，其返回结果是一个能用作条件的表达式
  - 标准库只能接受 ，一元谓词 和 二元谓词。

- #### 排序算法 （stable_sort）

  - **stable_sort —— 可以保持 等长元素 间的字典序**

### 10.3.2    lambda 表达式

*当我们希望传递两个以上的谓词可以使用 lambda 表达式*

- #### 介绍lambda

  - 一个 lambda 表达式 表示 一个可调用的代码单元。
  - 可以将其理解为 一个未命名的内联函数

```c++
[capture list] (para list) -> return type { function body }
/*
	capture list 是一个 lambda 所在函数中定义的局部变量的列表
	剩余的与任何的普通函数相同
	但是，lambda 必须使用 return
*/
```

- #### 向 lambda 传递函数

  - lambda 不能有默认参数

- #### 使用捕获列表

  - 空的捕获列表表明 此 lambda 不能使用它所在函数的任何局部变量

- #### 调用 find_if

- #### for_each 算法

- #### 完整的 biggies

***到此为止，从本章开头采用了一个例子来说明 泛型算法 和 lambda表达式，一定要跟着敲一遍代码***

**复习的时候也要看**

### 10.3.3    lambda 捕获和返回

- ####  值捕获

- #### 引用捕获

  - 如果我们采用用引用方式捕获一个变量，就必须确保被引用的对象在 lambda 执行的时候是存在的
  - 当我们从函数返回一个 lambda ，则同理 lambda 不能包含引用捕获

- #### 隐式捕获

  - 当我们混合使用隐式捕获和显示捕获的时候，捕获列表第一个元素必须是 & 或 =
  - 可以通过查看 表10.1 （P352）

- #### 可变 lambda

  - 如果你要改变一个被捕获变量的值，语序在参数列表加上 mutable

- #### 指定 lambda 返回类型

### 10.3.4    参数绑定（暂时略）



## 10.4    再探迭代器



