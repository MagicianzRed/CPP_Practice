# 第三章 字符串、向量和数组

## 3.1 命名空间的 using 声明

### 每个名字都需要独立的 using 声明

### 头文件不应该包含 using 声明



## 3.2 标准库类型 string

### 3.2.1 定义初始化 string 对象

#### 直接初始化和拷贝初始化

### 3.2.2 string对象上的操作

#### 读写 string 对象

#### 读取未知数量的 string 对象

#### 使用 getline 读取一整行

#### string 的 empty 和 size 操作

#### string::size_type 类型

* size()函数返回的是 string::size_type类型

#### 比较 string 对象

* 按照字典顺序（大小写敏感）

  

#### 为 string 对象赋值

#### 两个 string 对象相加

#### 字面值和 string 对象相加

* 在相加的时候可以允许把 字符字面值 和 字符串字面值相加
* 但是应当注意：相加的时候应当至少包含一个 string 对象

### 3.2.3 处理 string 对象中的字符

* cctype中，仅能改变单个字符的特性

```c++
for (declaration : expression)
{
    statment
}
/* expression 部分是一个对象，用于表示一个序列 */
/* declaration 部分负责定义一个变量，该变量将被用于访问序列中的基础元素, 
   每次迭代，declaration 部分的变量会被初始化为 expression 部分的下一个值 */

```

#### 使用范围 for 语句该被字符串中的字符

```c++
string s("Hello World!!!");
// 转换成大写形式
for (auto &c : s)	// 对于 s 中的每一个字符（注意：c是引用）（使用引用就能改变字符串中的值）
{
	c = toupper(c);	// c是一个引用，因此赋值语句将改变 s 中字符的值
}
cout << s << endl;
```

#### 只处理一部分字符串

#### 使用下标执行随机访问

## 3.3 标准库类型 vector

-  它是一个**类模板**
-  类模板：可以将其看作为编译器生成类或函数编写的一份说明
-  实例化：编译器根据模板创建**类**或者**函数**的过程称之为实例化

```c++
vector<int> ivec;				// ivec 保存 int 类型对象
vector<Sales_item> sales_vec;	 // 保存 Sales_item 类型的对象
vector<vector<string>> file;	 //  该向量的元素是 vector 对象
```

### 3.3.1定义和初始化 vector 对象

#### 列表初始化 vector 对象

```c++
vector<string> v1{"a", "an", "the"}; 	// 列表初始化
/*对象v1 包含三个元素：a, an, the*/
```

#### 创建指定数量的元素

```c++
vecotr<int> ivec(10, -1);	// 10个 int 型元素，每个都被初始化为 -1
```

#### 值初始化

#### 列表初始化还是元素数量

### 3.3.2 向 vector 对象中添加元素

*** 直接初始化方式用于3种情况 ***：

- 初始值已知
- 初始值是另一个对象的副本
- 所有元素初始值相同

### 3.3.3 其他 vector 操作

#### 计算 vector 内对象索引

#### 不能用下标形式添加元素

## 3.4 迭代器介绍

- 所有标准库中的容器都可以使用迭代器
- 迭代器可以与指针类比

### 3.4.1 使用迭代器

#### 迭代器运算符

#### 将迭代器从一个元素移动到另外一个元素

#### 迭代器类型

- const_iterator（只能读元素）
- iterator（可读可写）

#### begin  和 end  运算符

- c++ 新标准 cbegin 和 cend（他们将会返回 const_iterator 类型的返回值）

#### 结和解引用和成员访问操作

- (*it).mem == it->mem

#### 某些对 vector 对象的操作会使迭代器失效

### 3.4.2 迭代器运算

#### 		迭代器的算数运算

#### 		使用迭代器运算

```c++
// text 必须是有序的
// beg 和 end 表示我们的搜索范围
auto beg = text.begin(), end = text.end();
auto mid = text.begin() + (end - beg) / 2; 	// 初始状态下的中间点
/* 当还有元素尚未检查并且我们还没有找到 sought(这里使用具体字符串，在实现的时时候可以采用变量代替) 时执行循环 */
while ((mid != end) && (*mid != "sought"))
{
    if ("sought" < *mid) // 我们要找的元素在前半部分吗
    {
        end = mid;		// 如果是的，调整搜索范围忽略后半部分
	}
    else
    {
        beg = mid + 1;	// 否则在mid之后寻找
	}
    mid = beg + (end - beg) / 2;	// 更新中间点	
}

```



## 3.5 数组

### 3.5.1 定义和初始化内置数组

				#### 显示初始化数组元素
	
				#### 字符数组的特殊性

#### 不允许拷贝和赋值

### 3.5.2 访问数组元素

#### 检查下标的值

### 3.5.3 指针和数组

- 这里介绍了C++11的标准库中增加了两个函数，begin()，end()
- 他们可以返回数组中**首末**元素的**指针**，
- 记得要使用 using std::begin，来声明

#### 指针也是迭代器

#### 标准库函数 begin 和 end

#### 指针运算

```c++
auto n = end(arr) - begin(arr);		// auto 的类型为 ptrdiff_t （带符号类型）
```

#### 解引用和指针运算的交互

#### 下表和指针

### 3.5.4 C风格字符串

#### C标准库 String 函数

#### 比较字符串

#### 目标字符串的大小由调用者指定

### 3.5.5 与旧代码的接口

#### 混用 string 对象和 C 风格字符串

#### 使用数组初始化 vector 对象

​											***尽可能使用标准库类型而非数组***

## 3.6 多维数组

- 多维数组其实数组中的数组

```c++
int arr[10][20][30] = {0};
/*	1. arr 是一个大小为 10 的数组
	2. 它的每一个元素能存储的大小为 20 的数组
	3. 这些数组的元素又都是含有 30 个整数的数组
*/
```

### 多为数组的初始化

### 多为数组的下标引用

### 使用范围 for 语句处理多维数组

### 指针和多维数组

### 类型别名简化多为数组指针





