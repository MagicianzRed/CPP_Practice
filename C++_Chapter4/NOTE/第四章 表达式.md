# 第四章 表达式

## 4.1基础

### 4.1.1 基本概念

#### 组合运算符和运算按对象

#### 运算对象转换

#### 重载运算符

#### 左值和右值

- 简单归纳：当一个对象被用作**右值**的时候，用的是对象的**值（内容）**

  ​				当一个对象被用作**左值**的时候，用的是对象的**身份（在内存中的位置）**

### 4.1.2 优先级与结合律

- 当运算符的**优先级相同**的时候，将按照**从左向右**的顺序**组合**运算对象

#### 括号无视优先级与结合律

#### 优先级与结合律有何影响

### 4.1.3 求值顺序

```c++
int i = f1() * f2(); 	// 我们无法知道f1()和f2()谁先被求值

int i2 = 0;
std::cout << i2 << " " << ++i2 << endl;	// 未定义的，此表达式行为不可预知

```



#### 求值顺序、优先级、结合律

```c++
f() + g() * h() + j();
/*
	- 优先级规定，g()的返回值和h()的返回值相乘
	- 结合律规定，f()的返回值与g()和h()的乘积相加，所得结果再与j()的返回值相加
	- 对于这些函数的调用没有明确规定
*/
    
```

## 4.2 算数运算符

- bool值不应当参与计算（bool值会被提升成整形）（31页）
- 在C++早期版本中会允许结果为**负值**的**商**向上或者向下取整
- 在C++11中规定，一律向下（向0）取整

## 4.3 逻辑和关系运算符

### 逻辑与和逻辑或运算符

- 对于逻辑与，当且仅当**左侧**运算对象为**真**的时候才会对**右侧**运算对象求值
- 对于逻辑或，当且仅当**左侧**运算对象为**假**的时候才会对**右侧**运算对象求值
- **短路求值**：当且仅当左侧运算符无法确定表达式的结果的时候才会计算右侧运算对象的值

#### 逻辑非运算符

#### 关系运算符

#### 相等性测试与布尔字面值

## 4.4 赋值运算符

- 赋值运算符的**左侧**运算对象必须是一个**可修改的左值**

#### 赋值运算满足右结合律

#### 赋值运算符优先级较低

#### 切勿混淆相等运算符和赋值运算符

#### 复合赋值运算符

- 使用复合运算符只求值一次
- 使用普通的运算符则求值两次

## 4.5 递增和递减运算符

- 除非必须，否则不使用后置版本的递增或递减运算符

#### 在一条语句中混用解引用和递增运算符

```c++
*pbeg++;
/*
	1.这里使用后置++的是
	2.如果使用前置++，将会解引用指针递增后的值，如果此时已经在地址末尾，则会引发错误
	3.因此在使用++前置或者后置++的时候，应当仔细检查对应的操作数
*/
```

#### 运算对象可按照任意顺序求值

```c++
while ((end != s.end()) && (!isspace(*beg)))
{
    *beg = toupper(*beg++);		// 错误：该赋值语句未定义
}
/*
	1. 问题在于：赋值运算符左右两端的运算对象都用到了beg
	2. 正是因为此时运算对象可以任意顺序求值，因此编译器可以按照以下任意一种处理
		A. *beg = toupper(*beg);		    // 如果先求左侧
		B. *(beg + 1) = toupper(*beg);		// 如果先求右侧的值
*/
```

## 4.6 成员访问运算符

## 4.7 条件运算符

- （cond ? expr1 : expr2）
-  首先求 cond 的值
-  如果条件为真，则对 expr1 求值
  -  				否则对 expr2 求值 

## 4.8 位运算符

#### 位移运算符

#### 位求反运算符

#### 使用位运算符

```c++
/*检查班上30个同学的一次小测验*/

/*现在假设27号同学通过测验*/
unsigned long quiz1 = 0;   // 该值表示全班同学通过测验情况

1UL << 27;	// 生成一个值，该值只有第27位为1
quiz1 |= 1UL << 27;			// 表示学生27通过了测验

/*后来检查发现27号同学没通过*/
quiz1 &= ~(1UL << 27);		// 表示学生27没有通过测验

/*最后我门再检查一次*/
bool status = quiz1 & (1UL << 27)	// 检查27号同学是否通过测验

```

#### 位移运算符（又叫 IO 运算符）满足左结合律

## 4.9 sizeof 运算符

- sizeof 运算符的结果依赖于其作用的类型：
  - 对 char 或者类型为 char 的表达式执行 sizeof 运算，结果得1
  - 对**引用类型**执行 sizeof 运算得到**被引用对象**所占空间大小
  - 对**指针**执行 sizeof 运算得到指针本身所占空间大小
  - 对**解引用的指针**执行 sizeof 运算得到**指针指向的对象**所占空间的大小（指针可以时无效的）
  - 对**数组**执行 sizeof运算得到**整个数组**所占空间大小
  - 对 string 对象或者 vector 对象执行 sizeof 运算只返回该类型**固定部分**的大  ?**存疑**?

## 4.10 逗号运算符

- 首先对左侧表达式求值
- 将求值的结果丢弃掉——**？怎么丢弃 ？**
- 逗号运算符真正的结果是右侧表达式

## 4.11 类型转换

- 两种类型可以相互转换，那么他们就是关联的

#### 何时发生隐式转换

- 再大多数表达式中，比 int 类型小的整型值首先提升为较大整数类型
- 在条件中，非布尔值转换成布尔值
- 初始化过程中，初始值转换成变量的类型；在赋值语句中，**右侧**运算对象转换成**左侧**运算对象的类型
- 如果**算数运算**或**关系运算**的运算对象有多种类型，需要转换成同一种类型
- 函数调用时也会发生类型转换

### 4.11.1 算数转换

- 运算符的运算对象将转换成最宽的类型

#### 整形提升

- 负责把小整数类型转换成较大的整数类型	
- 较大的 char 类型（wchar_t、char16_t、char32_t）会被提生成int、unsigned int等等
- 前提是转换后的类型要能容纳所有的可能值

#### 无符号的运算对象

- 如果一个运算对象是无符号类型、另外一个运算对象是带符号类型，而且其中的**无符号**类型要**不小于带符号**的类型，那么**带符号**的运算对象转换成**无符号**的
- 反之也成立

#### 理解算数转换

- 通过大量的例子研究

#### 4.11.2 其他隐式转换

- **数组转换成指针**：大多数表达式中，数组自动转换成指向数组首元素的指针
- **指针转换**：
  - **转换成布尔类型**：
  - **转换成常量**：允许将**非常量**类型的指针转成**相应的常量**类型指针

- **类型定义转换**：类类型能定义由编译器自动执行的转换，不过编译器每次只能执行一种类类型转换

### 4.11.3 显示转换

- 本质上这种方法很危险

#### 命名的强制类型转换

```c++
/*一个命名的强制类型转换具有如下形式*/
cast_name<type>(expression);
/*
	type:转换的目标类型
	expression:需要转换的值
	cast_name: static_cast、dynamic_cast、const_cast 和 reinterpret_cast 中的一种
*/
```

- **static_cast**：任何具有明确定义的转换，只要不包含底层const，都可以使用 static_cast
- **const_cast**：只能改变**底层const（57页）**
- **reinterpret_cast**：通常为运算对象的位模式提供较低层次上的重新解释？？？？？？
  - reinterpret_cast本质上依赖于机器
  - 想要安全的使用 reinterpret_cast 必须对涉及的类型和编译器实现的转换过程都非常了解

**强烈建议避免使用强制类型转换**