# 第一章
**指令集架构**：
- 描述的是每条机器代码指令的效果。
是如何实现的。

***DMA***(直接存储器)：可以不通过处理器而直接到达贮存（第6章讨论）

**高速缓存**：
- 存放可能经常访问的数据。
    - 可以不用将所有的东西往**主存**里面放了。
    - 可以将程序的性能提升一个数量级。

## 操作系统
**可以看成应用程序和硬件之间插入的一层软件**
**微体系结构**：
- 描述的是处理器实际上
- 所有的应用程序对硬件的操作必须通过操作系统

***所有的操作系统都有的基本两个功能***
- 防止硬件被失控的应用程序滥用
- 向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。

***通过 进程、虚拟内存和文件 来实现上述两个功能***

## 进程 —— 处理器、主存和I/O设备的抽象表示
### 多个进程 —— 并发运行
**并发运行**
- 一个进程的指令和另外一个进程的指令是交错运行的。

**操作系统实现这种交错执行的机制称之为 —— 上下文切换**
#### 上下文切换
- **上下文**：操作系统**保持跟踪进程运行**所需的所有**状态信息**

- **切换**：操作系统把控制权**当前进程**转移到新的**新的进程**
    - 就是说，保存当前进程的上下文，恢复新进程的上下文。

## 线程 —— 多个线程的执行单元可以组成一个进程

## 虚拟内存 —— 它为每一个进程提供了一个假象，即每个进程都在单独使用主存。
**虚拟地址空间**：每个进程看到的内存都是一致的。

## 文件 —— 字节序列

**每一个I/O设备，包括磁盘、键盘、显示器，甚至网络，都额可以看成是文件。**

## Amdahl 定律
**主要思想** ：当我们对系统的某个部分加速的时候，其对系统整体性能的影响取决于该部分的重要性和加速程度。

# 第二章
**补码**：表示有符号樟树 的最常见的方式

**浮点数**：表示实数的科学计数法的以2为技术的版本

## 寻址和字节排序
**排列1——当阅读字节顺序相对不重要的时候**：考虑一个w位的整数，最高有效位x(w - 1),最低x(0)

***int : 0x01234567***

**大端法**：01 23 45 67
**小端法**：67 45 23 01

**ARM：大端小端都可以**
**Android和IOS——只能运行小端模式**

**排列2——阅读字节顺序重要的时候，一般发生在机器级程序**：

## 布尔代数
**异或**：P或者Q为真不同时为真时候，P^Q = 1

### C语言中的逻辑运算
**逻辑运算符&&和||，对应的 | 和 & 重要区别**: 如果第一个参数求值就能确定表达式的结果，那么逻辑运算符就不会对第二个参数求值。如：a&&5/a 就不会被零除。

### ***C语言中的位移运算***
- **x<<k**：x向左移动k位，丢弃最高的k位，并且在又端补k个0。

- **x<<j<<k**：等价于 (x<<j)<<k

***逻辑右移和算数右移***：**x>>k**
- **逻辑右移**：左端补k个零。
- **算数右移**：左端补k个最高有效位的值。

***在JAVA中就又明确规定，逻辑右移和算数右移，但在C语言中没有规定***

***如果要移动的k>=w位会发生什么？***

### 无符号数编码的定义
- **Binary to Unsigned =  B2U —— 二进制到无符号。**
- **U2B —— 无符号到二进制，唯一性**

### 补码编码
- Binary to Two's-complement = B2T
- 将字的最高有效位解释为负权
- 补码编码也具有唯一性

### 有符号数和无符号数之间的转换
**补码的机器直接强制转换不会转换成相同的数，因为，C语言的实现是从位级角度来看，而不是数学的角度。—— 数值可能会改变，但是位模式不变**

### T2U 的一般行为
**将一个有符号的数映射位它相应的无符号数时，负数就被转换成了大的正数，而非负数保持不变。**

### U2T 的一般行为
**对于小的数（<= TMax），从无符号到有符号的转换将保留数字的原值。对于大于的数（>TMax），数字将被转换位一个负数值。**

***当你执行一个运算，如果一个运算数有符号，另外一个没有，那么C语言将会将 有符号的参数强制转换为无符号的参数，并且假设这两个数都是非负数。***

### 零扩展 ——— 简单的在开头添加0即可（无符号数的零扩展）
### 补码数 —— 在开头加F

### 截断数字
**截断无符号数字**

